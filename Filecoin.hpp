/**
 * This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!
 */

#ifndef JSONRPC_CPP_STUB_LOTUS_FILECOIN_H_
#define JSONRPC_CPP_STUB_LOTUS_FILECOIN_H_

#include <jsonrpccpp/client.h>

namespace lotus {
    class Filecoin : public jsonrpc::Client
    {
        public:
            Filecoin(jsonrpc::IClientConnector &conn, jsonrpc::clientVersion_t type = jsonrpc::JSONRPC_CLIENT_V2) : jsonrpc::Client(conn, type) {}

            Json::Value BeaconGetEntry(int param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.BeaconGetEntry",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainDeleteObj(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainDeleteObj",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetBlock(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetBlock",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetBlockMessages(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetBlockMessages",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetGenesis() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ChainGetGenesis",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetMessage(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetMessage",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetNode(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetNode",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetParentMessages(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetParentMessages",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetParentReceipts(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetParentReceipts",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetPath(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ChainGetPath",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetRandomnessFromBeacon(const Json::Value& param01, int param02, int param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.ChainGetRandomnessFromBeacon",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetRandomnessFromTickets(const Json::Value& param01, int param02, int param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.ChainGetRandomnessFromTickets",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetTipSet(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainGetTipSet",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainGetTipSetByHeight(int param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ChainGetTipSetByHeight",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool ChainHasObj(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainHasObj",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainHead() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ChainHead",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string ChainReadObj(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainReadObj",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainSetHead(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainSetHead",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ChainStatObj(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ChainStatObj",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string ChainTipSetWeight(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ChainTipSetWeight",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientCalcCommP(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientCalcCommP",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientCancelDataTransfer(int param01, const std::string& param02, bool param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.ClientCancelDataTransfer",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientCancelRetrievalDeal(int param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientCancelRetrievalDeal",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientDealPieceCID(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientDealPieceCID",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientDealSize(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientDealSize",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientFindData(const Json::Value& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ClientFindData",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientGenCar(const Json::Value& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ClientGenCar",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientGetDealInfo(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientGetDealInfo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string ClientGetDealStatus(int param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientGetDealStatus",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool ClientHasLocal(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientHasLocal",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientImport(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientImport",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientListDataTransfers() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ClientListDataTransfers",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientListDeals() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ClientListDeals",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientListImports() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ClientListImports",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientListRetrievals() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.ClientListRetrievals",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientMinerQueryOffer(const std::string& param01, const Json::Value& param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.ClientMinerQueryOffer",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientQueryAsk(const std::string& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ClientQueryAsk",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientRemoveImport(int param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientRemoveImport",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientRestartDataTransfer(int param01, const std::string& param02, bool param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.ClientRestartDataTransfer",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientRetrieve(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.ClientRetrieve",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value ClientRetrieveTryRestartInsufficientFunds(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientRetrieveTryRestartInsufficientFunds",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string ClientStartDeal(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientStartDeal",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string ClientStatelessDeal(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.ClientStatelessDeal",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value CreateBackup(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.CreateBackup",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string GasEstimateFeeCap(const Json::Value& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.GasEstimateFeeCap",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            int GasEstimateGasLimit(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.GasEstimateGasLimit",p);
                if (result.isIntegral())
                    return result.asInt();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string GasEstimateGasPremium(int param01, const std::string& param02, int param03, const Json::Value& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.GasEstimateGasPremium",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value GasEstimateMessageGas(const Json::Value& param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.GasEstimateMessageGas",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MarketAddBalance(const std::string& param01, const std::string& param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MarketAddBalance",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string MarketGetReserved(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MarketGetReserved",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MarketReleaseFunds(const std::string& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MarketReleaseFunds",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MarketReserveFunds(const std::string& param01, const std::string& param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MarketReserveFunds",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MarketWithdraw(const std::string& param01, const std::string& param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MarketWithdraw",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MinerCreateBlock(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MinerCreateBlock",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MinerGetBaseInfo(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MinerGetBaseInfo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolBatchPush(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolBatchPush",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolBatchPushMessage(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MpoolBatchPushMessage",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolBatchPushUntrusted(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolBatchPushUntrusted",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolCheckMessages(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolCheckMessages",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolCheckPendingMessages(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolCheckPendingMessages",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolCheckReplaceMessages(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolCheckReplaceMessages",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolClear(bool param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolClear",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolGetConfig() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.MpoolGetConfig",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            int MpoolGetNonce(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolGetNonce",p);
                if (result.isIntegral())
                    return result.asInt();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolPending(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolPending",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolPush(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolPush",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolPushMessage(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MpoolPushMessage",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolPushUntrusted(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolPushUntrusted",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolSelect(const Json::Value& param01, double param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MpoolSelect",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MpoolSetConfig(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.MpoolSetConfig",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigAddApprove(const std::string& param01, const std::string& param02, int param03, const std::string& param04, const std::string& param05, bool param06) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                Json::Value result = this->CallMethod("Filecoin.MsigAddApprove",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigAddCancel(const std::string& param01, const std::string& param02, int param03, const std::string& param04, bool param05) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                Json::Value result = this->CallMethod("Filecoin.MsigAddCancel",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigAddPropose(const std::string& param01, const std::string& param02, const std::string& param03, bool param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.MsigAddPropose",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigApprove(const std::string& param01, int param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MsigApprove",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigApproveTxnHash(const std::string& param01, int param02, const std::string& param03, const std::string& param04, const std::string& param05, const std::string& param06, int param07, const std::string& param08) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                p.append(param07);
                p.append(param08);
                Json::Value result = this->CallMethod("Filecoin.MsigApproveTxnHash",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigCancel(const std::string& param01, int param02, const std::string& param03, const std::string& param04, const std::string& param05, int param06, const std::string& param07) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                p.append(param07);
                Json::Value result = this->CallMethod("Filecoin.MsigCancel",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigCreate(int param01, const Json::Value& param02, int param03, const std::string& param04, const std::string& param05, const std::string& param06) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                Json::Value result = this->CallMethod("Filecoin.MsigCreate",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string MsigGetAvailableBalance(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MsigGetAvailableBalance",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigGetPending(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MsigGetPending",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string MsigGetVested(const std::string& param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.MsigGetVested",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigGetVestingSchedule(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.MsigGetVestingSchedule",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigPropose(const std::string& param01, const std::string& param02, const std::string& param03, const std::string& param04, int param05, const std::string& param06) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                Json::Value result = this->CallMethod("Filecoin.MsigPropose",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigRemoveSigner(const std::string& param01, const std::string& param02, const std::string& param03, bool param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.MsigRemoveSigner",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigSwapApprove(const std::string& param01, const std::string& param02, int param03, const std::string& param04, const std::string& param05, const std::string& param06) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                p.append(param06);
                Json::Value result = this->CallMethod("Filecoin.MsigSwapApprove",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigSwapCancel(const std::string& param01, const std::string& param02, int param03, const std::string& param04, const std::string& param05) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                p.append(param05);
                Json::Value result = this->CallMethod("Filecoin.MsigSwapCancel",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value MsigSwapPropose(const std::string& param01, const std::string& param02, const std::string& param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.MsigSwapPropose",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value NodeStatus(bool param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.NodeStatus",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            int PaychAllocateLane(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychAllocateLane",p);
                if (result.isIntegral())
                    return result.asInt();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychAvailableFunds(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychAvailableFunds",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychAvailableFundsByFromTo(const std::string& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.PaychAvailableFundsByFromTo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychCollect(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychCollect",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychGet(const std::string& param01, const std::string& param02, const std::string& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.PaychGet",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string PaychGetWaitReady(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychGetWaitReady",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychList() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.PaychList",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychNewPayment(const std::string& param01, const std::string& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.PaychNewPayment",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychSettle(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychSettle",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychStatus(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychStatus",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string PaychVoucherAdd(const std::string& param01, const Json::Value& param02, const std::string& param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherAdd",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool PaychVoucherCheckSpendable(const std::string& param01, const Json::Value& param02, const std::string& param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherCheckSpendable",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychVoucherCheckValid(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherCheckValid",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychVoucherCreate(const std::string& param01, const std::string& param02, int param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherCreate",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychVoucherList(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherList",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value PaychVoucherSubmit(const std::string& param01, const Json::Value& param02, const std::string& param03, const std::string& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.PaychVoucherSubmit",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateAccountKey(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateAccountKey",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateAllMinerFaults(int param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateAllMinerFaults",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateCall(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateCall",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateChangedActors(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateChangedActors",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateCirculatingSupply(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateCirculatingSupply",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateCompute(int param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateCompute",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateDealProviderCollateralBounds(int param01, bool param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateDealProviderCollateralBounds",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateDecodeParams(const std::string& param01, int param02, const std::string& param03, const Json::Value& param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.StateDecodeParams",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateGetActor(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateGetActor",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateListActors(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateListActors",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateListMessages(const Json::Value& param01, const Json::Value& param02, int param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateListMessages",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateListMiners(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateListMiners",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateLookupID(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateLookupID",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMarketBalance(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMarketBalance",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMarketDeals(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateMarketDeals",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMarketParticipants(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateMarketParticipants",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMarketStorageDeal(int param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMarketStorageDeal",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerActiveSectors(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerActiveSectors",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateMinerAvailableBalance(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerAvailableBalance",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerDeadlines(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerDeadlines",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerFaults(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerFaults",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerInfo(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerInfo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateMinerInitialPledgeCollateral(const std::string& param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateMinerInitialPledgeCollateral",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerPartitions(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateMinerPartitions",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerPower(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerPower",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateMinerPreCommitDepositForPower(const std::string& param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateMinerPreCommitDepositForPower",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerProvingDeadline(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerProvingDeadline",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerRecoveries(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerRecoveries",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool StateMinerSectorAllocated(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateMinerSectorAllocated",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerSectorCount(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateMinerSectorCount",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateMinerSectors(const std::string& param01, const Json::Value& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateMinerSectors",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateNetworkName() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.StateNetworkName",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            int StateNetworkVersion(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateNetworkVersion",p);
                if (result.isIntegral())
                    return result.asInt();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateReadState(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateReadState",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateReplay(const Json::Value& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateReplay",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateSearchMsg(const Json::Value& param01, const Json::Value& param02, int param03, bool param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.StateSearchMsg",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateSectorExpiration(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateSectorExpiration",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateSectorGetInfo(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateSectorGetInfo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateSectorPartition(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateSectorPartition",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateSectorPreCommitInfo(const std::string& param01, int param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.StateSectorPreCommitInfo",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateVMCirculatingSupplyInternal(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateVMCirculatingSupplyInternal",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateVerifiedClientStatus(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateVerifiedClientStatus",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateVerifiedRegistryRootKey(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.StateVerifiedRegistryRootKey",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string StateVerifierStatus(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.StateVerifierStatus",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value StateWaitMsg(const Json::Value& param01, int param02, int param03, bool param04) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                p.append(param04);
                Json::Value result = this->CallMethod("Filecoin.StateWaitMsg",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string SyncCheckBad(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncCheckBad",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncCheckpoint(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncCheckpoint",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncMarkBad(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncMarkBad",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncState() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.SyncState",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncSubmitBlock(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncSubmitBlock",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncUnmarkAllBad() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.SyncUnmarkAllBad",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value SyncUnmarkBad(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncUnmarkBad",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool SyncValidateTipset(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.SyncValidateTipset",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string WalletBalance(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletBalance",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string WalletDefaultAddress() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.WalletDefaultAddress",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletDelete(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletDelete",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletExport(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletExport",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool WalletHas(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletHas",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string WalletImport(const Json::Value& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletImport",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletList() 
            {
                Json::Value p;
                p = Json::arrayValue;
                Json::Value result = this->CallMethod("Filecoin.WalletList",p);
                if (result.isArray())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string WalletNew(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletNew",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletSetDefault(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletSetDefault",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletSign(const std::string& param01, const std::string& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.WalletSign",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            Json::Value WalletSignMessage(const std::string& param01, const Json::Value& param02) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                Json::Value result = this->CallMethod("Filecoin.WalletSignMessage",p);
                if (result.isObject())
                    return result;
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            std::string WalletValidateAddress(const std::string& param01) 
            {
                Json::Value p;
                p.append(param01);
                Json::Value result = this->CallMethod("Filecoin.WalletValidateAddress",p);
                if (result.isString())
                    return result.asString();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
            bool WalletVerify(const std::string& param01, const std::string& param02, const Json::Value& param03) 
            {
                Json::Value p;
                p.append(param01);
                p.append(param02);
                p.append(param03);
                Json::Value result = this->CallMethod("Filecoin.WalletVerify",p);
                if (result.isBool())
                    return result.asBool();
                else
                    throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
            }
    };

}
#endif //JSONRPC_CPP_STUB_LOTUS_FILECOIN_H_
